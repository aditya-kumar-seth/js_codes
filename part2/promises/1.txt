promise ---

    object which represents a value which may be available now, or in the future, or never.
    this is a placeholder for a value that will be known later.
    a promise is in one of these states:
        - pending: initial state, neither fulfilled nor rejected.
        - fulfilled: meaning that the operation completed successfully.
        - rejected: meaning that the operation failed.
        - settled: the promise is either fulfilled or rejected.
    
    a promise is settled using the resolve and reject functions passed to the executor function.
    once a promise is settled, it can never change again.
    a promise can be created using the --- Promise constructor --- which takes --------- an executor function as an argument-----------.
    the executor function is called -- immediately -- by the Promise implementation, passing resolve and reject functions (the
    executor is called before the Promise constructor even returns the created object).
    resolve and reject functions are used to settle the promise.
    the resolve function is called when the asynchronous operation completes successfully, and the reject function is called
    when the operation fails.
    for an example:


                                        const myPromise = new Promise((resolve, reject) => {//new is used to create a new instance of a promise
                                            // do something asynchronous meaning not blocking the main thread like fetching data from an API or reading a file
                                            setTimeout(() => {
                                                const success = true; // or false based on some condition
                                                if (success) {
                                                    resolve('Operation was successful!');//resolve function is called when the operation is successful
                                                } else {
                                                    reject('Operation failed.');
                                                }
                                            }, 1000);
                                        });
    in this example, a new promise is created that simulates an asynchronous operation using setTimeout.
    after 1 second, it randomly either resolves or rejects the promise based on the value of the success variable.
    once a promise is settled (either resolved or rejected), it can be handled using the then, catch, and finally methods.

   --- the then method is used to specify what to do when the promise is fulfilled.
   --- the catch method is used to specify what to do when the promise is rejected.
   --- the finally method is used to specify what to do when the promise is settled (either fulfilled or rejected).
    for example:
   
                                        myPromise
                                            .then((message) => {//message is the value passed to the resolve function
                                                console.log('Success:', message);
                                            })
                                            .catch((error) => {//error is the value passed to the reject function
                                                console.error('Error:', error);
                                            })
                                            .finally(() => {
                                                console.log('Promise has been settled.');
                                            });                  

            then gets the value passed to the resolve function as an argument
            catch gets the value passed to the reject function as an argument
            finally does not get any arguments, it is just called when the promise is settled.   

then, catch, and finally methods also return a new promise, which allows for chaining multiple asynchronous operations together.
for example:
                                        myPromise
                                            .then((message) => {
                                                console.log('First success:', message);
                                                return 'Data from first then';      // returning a value to the next then
                                            })
                                            .then((data) => {                       //here data is 'Data from first then'
                                                console.log('Second success:', data);
                                                // you can also return a new promise here
                                                return new Promise((resolve) => {
                                                    setTimeout(() => {
                                                        resolve('Data from second then after delay');
                                                    }, 1000);
                                                });
                                            })
                                            .then((data) => {
                                                console.log('Third success:', data);
                                            })
                                            .catch((error) => {
                                                console.error('Error:', error);
                                            })
                                            .finally(() => {
                                                console.log('Promise chain has been settled.');
                                            });     



handling promises using async/await syntax:
    async/await is a syntactic sugar over promises, which makes it easier to work with asynchronous code.
    an async function is a function that returns a promise.
    the await keyword can be used inside an async function to wait for a promise to be settled.
    for example:

                                        async function fetchData() {
                                            try {
                                                const result = await myPromise; // wait for the promise to be settled
                                                console.log('Result:', result);
                                            } catch (error) {
                                                console.error('Error:', error);
                                            } finally {
                                                console.log('Fetch operation completed.');
                                            }
                                        }

    in this example, the fetchData function is declared as async, which means it returns a promise.
    inside the function, the await keyword is used to wait for myPromise to be settled.
    if the promise is fulfilled, the result variable will contain the value passed to the resolve function.
    if the promise is rejected, the error variable will contain the value passed to the reject function and result will not be assigned and result will be undefined.
    the finally block will always be executed after the try and catch blocks, regardless of whether the promise was fulfilled or rejected.


    when to use then catch finally vs async await:
        - use then, catch, and finally when you want to chain multiple asynchronous operations together.
        - use async/await when you want to write asynchronous code that looks like synchronous code.
        - async/await is generally easier to read and understand, especially for complex asynchronous operations.
        - however, async/await can only be used inside async functions, while then, catch, and finally can be used anywhere.

------------- so in general use async/await for most cases unless u need to chain multiple asynchronous operations together.


note that response.json() is also a promise, so you can use await on it as well. because to convert the response body to JSON format, it may take some time, especially for large responses.
